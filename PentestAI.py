from ctransformers import AutoModelForCausalLM
from transformers import AutoTokenizer
from colorama import Fore
import torch
import subprocess
import os
import re
import logging
import concurrent.futures
import signal
import json
import socket

# Configure logging
logging.basicConfig(filename='pentest_ai_log.txt', level=logging.INFO, format='%(asctime)s - %(message)s')

# Timeout handler to prevent long-running commands
def timeout_handler(signum, frame):
    raise TimeoutError("Command execution timed out.") 

# Validate IP address
def validate_ip(ip):
    pattern = re.compile(r"^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$")
    if not pattern.match(ip):
        print(Fore.RED + "Invalid IP address. Try again." + Fore.WHITE)
        return False
    try:
        socket.gethostbyname(ip)
        return True
    except socket.error:
        print(Fore.RED + f"Cannot resolve IP address: {ip}" + Fore.WHITE)
        return False

# Ensure essential tools are installed
def check_and_install_tools(tools):
    print(Fore.YELLOW + "Checking for necessary pentesting tools..." + Fore.WHITE)
    for tool in tools:
        result = subprocess.run(['which', tool], stdout=subprocess.PIPE)
        if not result.stdout.strip():
            print(Fore.RED + f"{tool} is not installed. Installing..." + Fore.WHITE)
            subprocess.run(['sudo', 'apt-get', 'install', '-y', tool])
        else:
            logging.info(f"{tool} installed.")
    print(Fore.GREEN + "Tool check complete." + Fore.WHITE)

# Initialize model and tokenizer
tokenizer = AutoTokenizer.from_pretrained("ArmurAI/Pentest_AI")
model_path = "<path>/Pentest_LLM.gguf"
model = AutoModelForCausalLM.from_pretrained(model_path, gpu_layers=16, threads=1, context_length=4096, max_new_tokens=-1)

def encode_prompt(role, prompt):
    return tokenizer.encode(f"{role}\n{prompt}\n")

def start_prompt(role):
    return f"{role}\n"

assistant_intro = (
    "Welcome to PentestAI. Provide the target IP to get started. "
    "Use 'exit' or 'hacked' to end the session at any time."
)
print(Fore.CYAN + assistant_intro + Fore.WHITE)

# Tools list
pentest_tools = ['nmap', 'metasploit-framework', 'john', 'wireshark', 'sqlmap', 'nikto', 'gobuster']
check_and_install_tools(pentest_tools)

# Session management functions
def save_session(data, filename='pentest_ai_session.json'):
    with open(filename, 'w') as f:
        json.dump(data, f)
    print(Fore.GREEN + "Session saved successfully." + Fore.WHITE)

def load_session(filename='pentest_ai_session.json'):
    if os.path.exists(filename):
        with open(filename, 'r') as f:
            return json.load(f)
    print(Fore.RED + "No saved session found. Starting fresh." + Fore.WHITE)
    return {}

# Execute commands with timeout and logging
def execute_command(command, simulate=False):
    if simulate:
        print(Fore.YELLOW + f"(Simulated) {command}" + Fore.WHITE)
        return "(Simulated Output)"
    
    try:
        signal.signal(signal.SIGALRM, timeout_handler)
        signal.alarm(30)  # Timeout set to 30 seconds
        result = subprocess.run(command.split(), stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        signal.alarm(0)  # Reset the alarm
        output = result.stdout.decode()
        logging.info(f"Command output: {output}")
        return output
    except TimeoutError:
        print(Fore.RED + f"Command '{command}' timed out." + Fore.WHITE)
    except Exception as e:
        print(Fore.RED + f"Error executing '{command}': {e}" + Fore.WHITE)
        logging.error(f"Error executing '{command}': {e}")
    return ""

# Customize command execution
def customize_command(tool, base_command):
    print(Fore.YELLOW + f"Customize {tool}. Add extra parameters or press Enter to use defaults:" + Fore.WHITE)
    extra_params = input(Fore.CYAN + f"{base_command}: " + Fore.WHITE).strip()
    return f"{base_command} {extra_params}" if extra_params else base_command

# Generate a pentest report
def generate_report(commands_executed, filename='pentest_report.txt'):
    with open(filename, 'w') as f:
        f.write("PentestAI Session Report\n========================\n")
        for tool, cmd in commands_executed.items():
            f.write(f"Tool: {tool}\nCommand: {cmd}\n\n")
    print(Fore.GREEN + f"Report saved to {filename}" + Fore.WHITE)

# Run the interactive pentesting loop
commands_executed = {}
simulation_mode = input(Fore.YELLOW + "Enable simulation mode? (yes/no): " + Fore.WHITE).strip().lower() == 'yes'
ip_address = input(Fore.YELLOW + "Enter the target IP: " + Fore.WHITE).strip()

while not validate_ip(ip_address):
    ip_address = input(Fore.YELLOW + "Enter a valid IP address: " + Fore.WHITE).strip()

while True:
    toks = encode_prompt("system", f"Target IP: {ip_address}")
    user_input = input(Fore.YELLOW + "\nEnter tool or 'exit': " + Fore.WHITE).strip().lower()

    if user_input in ['exit', 'hacked']:
        generate_report(commands_executed)
        break

    if user_input in pentest_tools:
        base_command = f"{user_input} {ip_address}"
        customized_command = customize_command(user_input, base_command)
        output = execute_command(customized_command, simulate=simulation_mode)
        commands_executed[user_input] = customized_command
        print(Fore.GREEN + f"Output:\n{output}" + Fore.WHITE)
    elif user_input == 'save':
        save_session({'commands': commands_executed, 'ip_address': ip_address})
    else:
        print(Fore.RED + f"Unknown tool or command: {user_input}" + Fore.WHITE)
